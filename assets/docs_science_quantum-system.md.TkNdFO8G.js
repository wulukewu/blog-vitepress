import{_ as e,o as r,c as t,a8 as i}from"./chunks/framework.D1nT80TK.js";const n="/images/posts/quantum-system/quantum_fourier_transform.png",p="/images/posts/quantum-system/quantum_shor_process.png",l="/images/posts/quantum-system/quantum_measurement_single.gif",s="/images/posts/quantum-system/bloch_sphere.png",$="/images/posts/quantum-system/entangled_measurement.png",o="/images/posts/quantum-system/quantum_measurement_multiple.gif",m="/images/posts/quantum-system/cnot_gate.png",g="/images/posts/quantum-system/cnot_gate_ex1.png",h="/images/posts/quantum-system/cnot_gate_ex2.png",d="/images/posts/quantum-system/cnot_gate_copy.png",c="/images/posts/quantum-system/cnot_gate_not.png",u="/images/posts/quantum-system/swap_gate_cnot.jpg",_="/images/posts/quantum-system/ccnot_gate.png",b="/images/posts/quantum-system/ccnot_gate_reversibility.png",x="/images/posts/quantum-system/and_gate.png",q="/images/posts/quantum-system/xor_gate.png",f="/images/posts/quantum-system/nand_gate.png",N="/images/posts/quantum-system/not_gate.png",P="/images/posts/quantum-system/or_gate.png",T="/images/posts/quantum-system/quantum_circuit_equivalence.png",B=JSON.parse('{"title":"量子計算基礎 - 從單量子位到多量子位系統","description":"","frontmatter":{"title":"量子計算基礎 - 從單量子位到多量子位系統","date":"2025-04-04T18:48:02.000Z","tags":["quantum","hilbert-space","algorithms","physics"],"mathjax":true,"lastUpdated":"2025-05-28T00:12:47.000Z"},"headers":[],"relativePath":"docs/science/quantum-system.md","filePath":"docs/science/quantum-system.md"}'),k={name:"docs/science/quantum-system.md"};function y(C,a,O,v,S,A){return r(),t("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1743792482000"},[...a[0]||(a[0]=[i('<p>大一下去修了一門量子計算的課，前面的概念跟線性代數有滿多相似的地方，後半部分才真正開始講量子演算法。</p><h2 id="量子計算基礎簡介" tabindex="-1">量子計算基礎簡介 <a class="header-anchor" href="#量子計算基礎簡介" aria-label="Permalink to &quot;量子計算基礎簡介&quot;">​</a></h2><p>量子電腦與傳統電腦的差別，在於傳統電腦儲存資訊的最小單位是位元（bit），量子電腦則是使用量子位元（qubit）。位元可以存在一種狀態，1 或是 0。量子位元特別的地方是，它在一個時間，可以同時是 1 也是 0。</p><p><img src="https://image-cdn.learnin.tw/bnextmedia/image/album/2024-04/img-1713263203-31716.jpg?output=webp&amp;w=1200" alt="bit vs qubit"></p><p>量子在通訊上有很高的安全性，利用量子力學原理，能夠在兩方之間安全地分發加密密鑰。任何試圖竊聽的行為都會擾亂量子態，被接收方檢測到。</p><p><img src="https://image-cdn.learnin.tw/bnextmedia/image/album/2024-04/img-1713263155-27502.jpg?output=webp&amp;w=1200" alt="quantum application"></p><p>過去超大整數的質因數分解，即使傳統超級電腦的運算能力也無法在短時間破解。不過，量子演算法（Shor&#39;s Algorithm，可解質因數分解）能在合理時間內完成破解，會顛覆現在 RSA 等加密算法。</p><h3 id="classical-v-s-quantum" tabindex="-1">Classical v.s. Quantum <a class="header-anchor" href="#classical-v-s-quantum" aria-label="Permalink to &quot;Classical v.s. Quantum&quot;">​</a></h3><h4 id="拆解質數" tabindex="-1">拆解質數 <a class="header-anchor" href="#拆解質數" aria-label="Permalink to &quot;拆解質數&quot;">​</a></h4><p>現在有個數字 $N = f_1 \\times f_2$，由 $f_1, f_2$ 兩個很大的質數構成。破解 RSA 的核心，就是從 $N$ 找出 $f_1$ 和 $f_2$。</p><p>想要找到 $N$ 的因數，只要不斷給定 $g$，透過 Euclid&#39;s Algorithm（歐幾里得演算法，又稱輾轉相除法）快速計算判斷，當 $g$ 使得公因數 $\\gcd(N, g) = a &gt; 1$ 時，對於 RSA 來說就已經結束了。</p><p>但要找到 $g$ 可以滿足上述條件其實並不容易，事實上真的只能一個一個猜 $g$ 是多少。不過，我們可以將這個隨機猜測的數字 $g$ 轉換成很有可能滿足條件的 $g^{p/2} \\pm 1$。</p><details><summary>為什麼是 $g^{p/2} \\pm 1$ ？</summary><p>若給定兩個數 $A, B$，且 $\\gcd(A, B) = 1$，則存在一個正整數 $p$ 使得 $A^p = m \\cdot B + 1$，其中 $m$ 為某個整數（根據歐拉定理）。</p><p>舉兩個例子來說：</p><p><strong>Ex1</strong></p><p>給定 $(A, B) = (7, 15)$，則：</p><p>$$ \\begin{align*} p &amp;= 2, &amp; 7^2 &amp;= 3 \\cdot 15 + 4 \\ p &amp;= 3, &amp; 7^3 &amp;= 22 \\cdot 15 + 13 \\ p &amp;= 4, &amp; 7^4 &amp;= 160 \\cdot 15 + 1 \\end{align*} $$</p><p><strong>Ex2</strong></p><p>給定 $(A, B) = (42, 13)$，則：</p><p>$$ \\begin{align*} p &amp;= 2, &amp; 42^2 &amp;= 135 \\cdot 13 + 9 \\ p &amp;= 3, &amp; 42^3 &amp;= 5699 \\cdot 13 + 1 \\end{align*} $$</p><p>因此，$m \\cdot B = A^p - 1 = \\left(A^{p/2}+1\\right)\\left(A^{p/2}-1\\right)$</p></details><p>將機會不大的數字 g 轉換成很有可能的$g^{p/2} \\pm 1$，只要找到這樣的$p$就好（$p$要是偶數才能真正拆解喔！）</p><h4 id="classical" tabindex="-1">Classical <a class="header-anchor" href="#classical" aria-label="Permalink to &quot;Classical&quot;">​</a></h4><p>我們用個例子來想，要用傳統電腦找到一個 $p$ 使得 $42^p = m \\times 13 + 1$，可能會從 $p=1,2,3,\\ldots$ 開始一個一個慢慢代入判斷，但如果現在給定 $g^p = m \\times N + 1$ 的 $g$ 和 $N$ 都很大呢？</p><p>對傳統電腦來說，就真的只能一個一個數字慢慢算，直到找到答案為止，這也就是為什麼現在能夠這麼廣泛地使用 RSA 加密。但是對量子電腦來說就不太一樣了……</p><h4 id="quantum" tabindex="-1">Quantum <a class="header-anchor" href="#quantum" aria-label="Permalink to &quot;Quantum&quot;">​</a></h4><p>用量子來計算的好處是因為有<strong>疊加態（superposition）</strong>。</p><p>我們可以構建一個 $f(x)$ 的函數。若要計算 $a, b, c, d$ 各自的函數值，對於傳統電腦來說，就是一個一個代入計算：</p><p>$$ f(a),\\quad f(b),\\quad f(c),\\quad f(d) $$</p><p>但在量子的世界，可以讓一個或多個量子位元處於疊加態：</p><p>$$ |a\\rangle + |b\\rangle + |c\\rangle + |d\\rangle $$</p><p>然後將這個疊加態輸入設計好的 $f(x)$ 邏輯閘做平行運算，得到：</p><p>$$ |f(a)\\rangle + |f(b)\\rangle + |f(c)\\rangle + |f(d)\\rangle $$</p><hr><p>到這邊還需要先知道另一個 Shor&#39;s Algorithm 的核心概念。一樣目標是找到滿足條件的 $p$。如果現在隨便找的一個 $x$，會得到 $g^x = mN + r$，其中 $r$ 是餘數，那麼很容易證明 $g^{x+p} = m_2 N + r$ 也成立。</p><p>換句話說，對於某個週期 $p$，$g^x$ 模 $N$ 的餘數會重複出現：</p><p>$$ g^x \\bmod N = r \\implies g^{x+p} \\bmod N = r $$</p><p>這個「週期性」就是 Shor&#39;s Algorithm 能有效率分解質因數的關鍵。只要能找到這個週期 $p$，就能透過 Quantum Fourier Transform（量子傅立葉變換）進一步拆解 $N$。</p><p><img src="'+n+'" alt="quantum fourier transform"></p><hr><p>前面提到，在量子的世界中，我們可以構建量子閘，讓所有輸入 $x$ 的餘數 $r$ 同時被計算出來：</p><p>$$ |x\\rangle \\longrightarrow |x\\rangle |g^x \\bmod N\\rangle $$</p><p>這表示，當量子位元處於疊加態時，經過適當設計的量子閘後，所有 $x$ 對應的 $g^x \\bmod N$ 都會同時存在於量子態中。</p><p><img src="'+p+'" alt="quantum shor process"></p><p>從這些餘數當中，任取一個 $r$，可以經由適當的轉換，將其餘的 $x$ 都變成 $0$。最後透過 Fourier Transform 找出的 $g = x$ 和 $p$，就可以利用前面提過的傳統方式，判斷 $g^{p/2} \\pm 1$ 是否與 $N$ 有公因數，將 $N$ 拆解開來。</p><hr><blockquote><p>標準的 2048 位元 RSA 加密，就算用目前世界上最強的超級電腦（太湖之光，中國製），花費地球年齡的時間（46 億年）都無法破解。</p></blockquote><p>如果量子電腦真的存在，能將運算時間由數十億年縮減為幾分、幾秒鐘，數字 $N$ 都能快速被拆解成 $f_1, f_2$ 兩個質數，現在的金融、通訊等都會受到嚴重的影響。但是現在還不需要擔心，因為目前的技術還沒辦法處理太多位元的數字，可能只能拆解 $15=3\\times5$ 這種容易的而已。</p><hr><h2 id="單量子位系統-single-qubit-quantum-systems" tabindex="-1">單量子位系統 (Single-Qubit Quantum Systems) <a class="header-anchor" href="#單量子位系統-single-qubit-quantum-systems" aria-label="Permalink to &quot;單量子位系統 (Single-Qubit Quantum Systems)&quot;">​</a></h2><p>在量子計算中，量子位元 (Qubit) 是最基本的資訊單位，類似於傳統計算中的位元 (Bit)。然而，與傳統位元只能處於 0 或 1 的狀態不同，量子位元可以同時處於 0 和 1 的疊加態。先來介紹一下量子計算所處於的空間定義：</p><h3 id="hilbert-空間-hilbert-space" tabindex="-1">Hilbert 空間 (Hilbert Space) <a class="header-anchor" href="#hilbert-空間-hilbert-space" aria-label="Permalink to &quot;Hilbert 空間 (Hilbert Space)&quot;">​</a></h3><p>對於單量子位元系統，Hilbert 空間是一個複數 $\\mathbb{C}$ 中的 inner product space，有向量加法、純量乘法，以及計算向量之間的內積。</p><blockquote><p>If $| \\psi \\rangle, | \\phi \\rangle \\in V$, $\\alpha, \\beta \\in \\mathbb{C}$, then $\\alpha | \\psi \\rangle + \\beta | \\phi \\rangle \\in V$.</p></blockquote><p>在單量子位元系統當中，我們常用$|0\\rangle=\\begin{pmatrix} 1 \\ 0 \\end{pmatrix}$, $|1\\rangle=\\begin{pmatrix} 0 \\ 1 \\end{pmatrix}$當作標準基底，而一個量子位元則可表示為 $| \\psi \\rangle = \\alpha | 0 \\rangle + \\beta | 1 \\rangle$。</p><p>至於維度 (Dimension) 為 $N$ 的向量空間，則會以 ${ | e_1 \\rangle, | e_2 \\rangle, \\dots, | e_N \\rangle }$ 當作標準基底，也可以寫成${ | 0 \\rangle, | 1 \\rangle, \\dots, | N-1 \\rangle }$ 。</p><p>$$|e_1\\rangle = \\begin{pmatrix} 1 \\ 0 \\ \\vdots \\ 0 \\end{pmatrix}, |e_2\\rangle = \\begin{pmatrix} 0 \\ 1 \\ \\vdots \\ 0 \\end{pmatrix}, \\ldots, |e_N\\rangle = \\begin{pmatrix} 0 \\ \\vdots \\ 0 \\ 1 \\end{pmatrix}$$</p><ul><li><strong>正規化 (Normalized)</strong>：$\\langle e_1 | e_1 \\rangle = \\langle e_2 | e_2 \\rangle = \\dots = \\langle e_N | e_N \\rangle = 1$</li><li><strong>正交 (Orthogoral)</strong>：$\\langle e_1 | e_2 \\rangle = \\langle e_2 | e_3 \\rangle = \\dots = \\langle e_{N-1} | e_N \\rangle = 0$</li></ul><p>因此：</p><p>$$ \\langle e_i | e_j \\rangle = \\delta_{ij} = \\begin{cases} 1 &amp; \\text{if } i = j \\ 0 &amp; \\text{if } i \\neq j \\end{cases} $$</p><p><strong>Note</strong>：單量子位元系統的 Hilbert 空間是一個 $N=2$ 的簡單空間，而複數量子位元系統的 Hilbert 空間維度會隨著量子位元數量增加而指數成長，例如 $n=5$ 個量子位元系統的 Hilbert 空間維度為 $N=2^5=32$。</p><h4 id="範例" tabindex="-1">範例 <a class="header-anchor" href="#範例" aria-label="Permalink to &quot;範例&quot;">​</a></h4><p>我們拿一個例子來說明好了，假設 $| \\psi \\rangle = \\begin{pmatrix} 1-i \\ 2 \\end{pmatrix}$, $| \\phi \\rangle = \\begin{pmatrix} 1 \\ 1+i \\end{pmatrix}$，那麼可以做下列這幾個運算：</p><h4 id="對偶向量-dual-vector" tabindex="-1">對偶向量 (Dual Vector) <a class="header-anchor" href="#對偶向量-dual-vector" aria-label="Permalink to &quot;對偶向量 (Dual Vector)&quot;">​</a></h4><ul><li>$\\langle \\psi | = \\begin{pmatrix} 1-i &amp; 2 \\end{pmatrix}^* = \\begin{pmatrix} 1+i &amp; 2 \\end{pmatrix}$</li><li>$\\langle \\phi | = \\begin{pmatrix} 1 &amp; 1+i \\end{pmatrix}^* = \\begin{pmatrix} 1 &amp; 1-i \\end{pmatrix}$</li></ul><h4 id="內積-inner-product" tabindex="-1">內積 (Inner Product) <a class="header-anchor" href="#內積-inner-product" aria-label="Permalink to &quot;內積 (Inner Product)&quot;">​</a></h4><p>$$ \\langle \\phi | \\psi \\rangle = \\begin{pmatrix} 1 &amp; 1-i \\end{pmatrix} \\begin{pmatrix} 1-i \\ 2 \\end{pmatrix} = 3(1-i) $$</p><p>$$ \\langle \\psi | \\phi \\rangle = \\begin{pmatrix} 1+i &amp; 2 \\end{pmatrix} \\begin{pmatrix} 1 \\ 1+i \\end{pmatrix} = 3(1+i) $$</p><p>$$ \\langle \\psi | \\psi \\rangle = \\begin{pmatrix} 1+i &amp; 2 \\end{pmatrix} \\begin{pmatrix} 1-i \\ 2 \\end{pmatrix} = 6 \\quad (\\in \\mathbb{R}_{\\geq 0}) $$</p><p>$$ \\langle \\phi | \\phi \\rangle = \\begin{pmatrix} 1 &amp; 1-i \\end{pmatrix} \\begin{pmatrix} 1 \\ 1+i \\end{pmatrix} = 3 \\quad (\\in \\mathbb{R}_{\\geq 0}) $$</p><p>因此：</p><ul><li>$\\langle v | v \\rangle \\in \\mathbb{R}_{\\geq 0}$ (non-negative real)</li><li>$\\langle v_1 | v_2 \\rangle = \\overline{\\langle v_2 | v_1 \\rangle}$</li><li>$(a \\langle v_2 | + b \\langle v_3 |)| v_1 \\rangle = a \\langle v_2 | v_1 \\rangle + b \\langle v_3 | v_1 \\rangle$</li></ul><h4 id="向量範數-norm" tabindex="-1">向量範數 (Norm) <a class="header-anchor" href="#向量範數-norm" aria-label="Permalink to &quot;向量範數 (Norm)&quot;">​</a></h4><p>$$ | \\psi | = \\sqrt{\\langle \\psi | \\psi \\rangle} $$</p><h4 id="正規化向量-normalized-vector" tabindex="-1">正規化向量 (Normalized Vector) <a class="header-anchor" href="#正規化向量-normalized-vector" aria-label="Permalink to &quot;正規化向量 (Normalized Vector)&quot;">​</a></h4><p>量子態必須是正規化的，以保證測量結果的機率總和為 1。</p><p>$$ | \\psi \\rangle_N = \\frac{| \\psi \\rangle}{| \\psi |} $$</p><p>例如：</p><p>$$ | \\psi \\rangle = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1-i \\ 2 \\end{pmatrix}, \\quad | \\phi \\rangle = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\ 1+i \\end{pmatrix} $$</p><p>計算內積：</p><p>$$ \\langle \\psi | \\psi \\rangle = \\frac{\\begin{pmatrix} 1+i &amp; 2 \\end{pmatrix}}{\\sqrt{6}} \\cdot \\frac{\\begin{pmatrix} 1-i \\ 2 \\end{pmatrix}}{\\sqrt{6}} = \\frac{6}{6} = 1 $$</p><p>$$ \\langle \\phi | \\phi \\rangle = \\frac{\\begin{pmatrix} 1 &amp; 1-i \\end{pmatrix}}{\\sqrt{3}} \\cdot \\frac{\\begin{pmatrix} 1 \\ 1+i \\end{pmatrix}}{\\sqrt{3}} = \\frac{3}{3} = 1 $$</p><h4 id="投影運算子-projection-operator" tabindex="-1">投影運算子 (Projection Operator) <a class="header-anchor" href="#投影運算子-projection-operator" aria-label="Permalink to &quot;投影運算子 (Projection Operator)&quot;">​</a></h4><p>$$ | \\psi \\rangle = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1-i \\ 2 \\end{pmatrix} = \\frac{1-i}{\\sqrt{6}} | e_1 \\rangle + \\frac{2}{\\sqrt{6}} | e_2 \\rangle $$</p><p>$$ \\langle e_1 | \\psi \\rangle = \\langle e_1 | \\left( \\frac{1-i}{\\sqrt{6}} | e_1 \\rangle + \\frac{2}{\\sqrt{6}} | e_2 \\rangle \\right) = \\frac{1-i}{\\sqrt{6}} \\langle e_1 | e_1 \\rangle + \\frac{2}{\\sqrt{6}} \\langle e_1 | e_2 \\rangle = \\frac{1-i}{\\sqrt{6}} $$</p><p>$$ \\langle e_2 | \\psi \\rangle = \\langle e_2 | \\left( \\frac{1-i}{\\sqrt{6}} | e_1 \\rangle + \\frac{2}{\\sqrt{6}} | e_2 \\rangle \\right) = \\frac{1-i}{\\sqrt{6}} \\langle e_2 | e_1 \\rangle + \\frac{2}{\\sqrt{6}} \\langle e_2 | e_2 \\rangle = \\frac{2}{\\sqrt{6}} $$</p><p>此時算出的 $\\langle e_1 | \\psi \\rangle = \\frac{1-i}{\\sqrt{6}}$ 和 $\\langle e_2 | \\psi \\rangle = \\frac{2}{\\sqrt{6}}$ 就分別是 $| \\psi \\rangle$ 在 $| e_1 \\rangle$ 和 $| e_2 \\rangle$ 兩個基底的投影運算子。</p><h4 id="崩塌-collapse" tabindex="-1">崩塌 (Collapse) <a class="header-anchor" href="#崩塌-collapse" aria-label="Permalink to &quot;崩塌 (Collapse)&quot;">​</a></h4><p>我們前面說過，$| \\psi \\rangle = \\sum_i \\alpha_i | e_i \\rangle$ 是由$N$維的基底所組成的。其中 $| e_i \\rangle$ 在 $| \\psi \\rangle$ 出現的機率為 $| \\alpha_i |^2$，則$|\\alpha_1|^2 + |\\alpha_2|^2 + \\dots + |\\alpha_N|^2 = 1$。</p><p>在 $| \\psi \\rangle = \\sum_i \\alpha_i | e_i \\rangle$ 當中，$| e_i \\rangle$ 出現的機率取決於 $| \\alpha_i |^2$，而此時的觀測是<strong>不可逆</strong>的。當測量完成後，量子態會崩塌到對應的基底態 $| e_i \\rangle$，並且無法回復到原本的疊加態。因此<strong>測量過程不可逆，且量子態的疊加性在測量後不復存在</strong>。</p><p><img src="'+l+'" alt="Quantum Measurement Single"></p><h4 id="範例-1" tabindex="-1">範例 <a class="header-anchor" href="#範例-1" aria-label="Permalink to &quot;範例&quot;">​</a></h4><p>$$ | \\psi \\rangle = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1-i \\ 2 \\end{pmatrix} = \\frac{1-i}{\\sqrt{6}} | e_1 \\rangle + \\frac{2}{\\sqrt{6}} | e_2 \\rangle $$</p><ul><li><p>$| e_1 \\rangle$ 在 $| \\psi \\rangle$ 出現的機率為 $\\left| \\frac{1-i}{\\sqrt{6}} \\right|^2 = \\frac{2}{6} = \\frac{1}{3}$</p></li><li><p>$| e_2 \\rangle$ 在 $| \\psi \\rangle$ 出現的機率為 $\\left| \\frac{2}{\\sqrt{6}} \\right|^2 = \\frac{4}{6} = \\frac{2}{3}$</p></li><li><p>$\\frac{1}{3} + \\frac{2}{3} = 1$</p></li></ul><h4 id="量子態-quantum-state" tabindex="-1">量子態 (Quantum State)： <a class="header-anchor" href="#量子態-quantum-state" aria-label="Permalink to &quot;量子態 (Quantum State)：&quot;">​</a></h4><p>$$ P_i | \\psi \\rangle \\rightarrow | e_i \\rangle $$</p><p>$$ | \\psi \\rangle = \\alpha_1 | e_1 \\rangle + \\alpha_2 | e_2 \\rangle $$</p><h4 id="經典態-classical-state" tabindex="-1">經典態 (Classical State)： <a class="header-anchor" href="#經典態-classical-state" aria-label="Permalink to &quot;經典態 (Classical State)：&quot;">​</a></h4><p>$$ \\frac{P_1}{| \\alpha_1 |^2} | \\psi \\rangle = \\frac{\\alpha_1}{| \\alpha_1 |^2} | e_1 \\rangle = e^{i\\theta_1} | e_1 \\rangle $$</p><p>$$ \\frac{P_2}{| \\alpha_2 |^2} | \\psi \\rangle = \\frac{\\alpha_2}{| \\alpha_2 |^2} | e_2 \\rangle = e^{i\\theta_2} | e_2 \\rangle $$</p><p>量子態在測量後會崩塌到某個基底態，而此時的經典態不再具有量子態的疊加性。</p><h3 id="bloch-球-bloch-sphere" tabindex="-1">Bloch 球 (Bloch Sphere) <a class="header-anchor" href="#bloch-球-bloch-sphere" aria-label="Permalink to &quot;Bloch 球 (Bloch Sphere)&quot;">​</a></h3><p>Bloch 球用於表示單量子位的狀態：<a href="/images/posts/quantum-system/spherical_vs_cartesian_coordinate_systems.mp4">video</a></p><p><img src="'+s+'" alt="Bloch Sphere"></p><ul><li>$| 0 \\rangle \\rightarrow (0, 0, 1)$</li><li>$| 1 \\rangle \\rightarrow (0, 0, -1)$</li><li>$| + \\rangle \\rightarrow (1, 0, 0)$</li><li>$| - \\rangle \\rightarrow (-1, 0, 0)$</li><li>$| i \\rangle \\rightarrow (0, 1, 0)$</li><li>$| -i \\rangle \\rightarrow (0, -1, 0)$</li></ul><h4 id="bloch-球上的-i-x-y-z-運算子幾何意義" tabindex="-1">Bloch 球上的 I, X, Y, Z 運算子幾何意義 <a class="header-anchor" href="#bloch-球上的-i-x-y-z-運算子幾何意義" aria-label="Permalink to &quot;Bloch 球上的 I, X, Y, Z 運算子幾何意義&quot;">​</a></h4><ul><li><strong>I (單位運算子)</strong>：不改變 Bloch 球上的狀態（即不旋轉）。</li><li><strong>X 門（Pauli-X）</strong>：繞 $x$ 軸旋轉 $\\pi$ 弧度（180°），將 $|0\\rangle$ 和 $|1\\rangle$ 互換。對應於 Bloch 球上的 $x$ 軸翻轉。</li><li><strong>Y 門（Pauli-Y）</strong>：繞 $y$ 軸旋轉 $\\pi$ 弧度（180°），將 $|0\\rangle$ 和 $|1\\rangle$ 互換，並帶有相位。對應於 Bloch 球上的 $y$ 軸翻轉。</li><li><strong>Z 門（Pauli-Z）</strong>：繞 $z$ 軸旋轉 $\\pi$ 弧度（180°），將 $|+\\rangle$ 和 $|-\\rangle$ 互換，$|0\\rangle$ 不變，$|1\\rangle$ 變號。對應於 Bloch 球上的 $z$ 軸翻轉。</li></ul><p>簡單來說，X, Y, Z 分別對應於 Bloch 球上繞 $x$、$y$、$z$ 軸的 180° 旋轉。</p><hr><h2 id="多量子位系統-multiple-qubit-systems" tabindex="-1">多量子位系統 (Multiple-Qubit Systems) <a class="header-anchor" href="#多量子位系統-multiple-qubit-systems" aria-label="Permalink to &quot;多量子位系統 (Multiple-Qubit Systems)&quot;">​</a></h2><h3 id="hilbert-空間與張量積-tensor-product" tabindex="-1">Hilbert 空間與張量積 (Tensor Product) <a class="header-anchor" href="#hilbert-空間與張量積-tensor-product" aria-label="Permalink to &quot;Hilbert 空間與張量積 (Tensor Product)&quot;">​</a></h3><p>多量子位系統的 Hilbert 空間是單量子位空間的張量積：</p><p>$$ H_2 \\otimes H_2 \\otimes \\dots \\otimes H_2 = H_N \\quad (N \\text{ 個}) $$</p><p>假設：</p><ul><li>第 0 個 $H_2$：${ | 0 \\rangle _0, | 1 \\rangle _0 }$</li><li>第 1 個 $H_2$：${ | 0 \\rangle _1, | 1 \\rangle _1 }$</li></ul><h4 id="tensor-product" tabindex="-1">Tensor Product <a class="header-anchor" href="#tensor-product" aria-label="Permalink to &quot;Tensor Product&quot;">​</a></h4><p>$H_2 \\otimes H_2:$</p><p>$$ | \\psi_1 \\rangle \\otimes | \\psi_0 \\rangle = [\\alpha_1 | 0 \\rangle_1 + \\beta_1 | 1 \\rangle_1] \\otimes [\\alpha_0 | 0 \\rangle_0 + \\beta_0 | 1 \\rangle_0] $$</p><p>$$ = \\alpha_1 \\alpha_0 | 0 \\rangle_1 \\otimes | 0 \\rangle_0 + \\alpha_1 \\beta_0 | 0 \\rangle_1 \\otimes | 1 \\rangle_0 + \\beta_1 \\alpha_0 | 1 \\rangle_1 \\otimes | 0 \\rangle_0 + \\beta_1 \\beta_0 | 1 \\rangle_1 \\otimes | 1 \\rangle_0 $$</p><p>$$ = \\alpha_1 \\alpha_0 | 00 \\rangle_{10} + \\alpha_1 \\beta_0 | 01 \\rangle_{10} + \\beta_1 \\alpha_0 | 10 \\rangle_{10} + \\beta_1 \\beta_0 | 11 \\rangle_{10} $$</p><p>而此時：</p><ul><li>$| 0 \\rangle_1 \\otimes | 0 \\rangle_0 = | 00 \\rangle_{10}$</li><li>$| 0 \\rangle_1 \\otimes | 1 \\rangle_0 = | 01 \\rangle_{10}$</li><li>$| 1 \\rangle_1 \\otimes | 0 \\rangle_0 = | 10 \\rangle_{10}$</li><li>$| 1 \\rangle_1 \\otimes | 1 \\rangle_0 = | 11 \\rangle_{10}$</li></ul><p>$| 00 \\rangle, | 01 \\rangle, | 10 \\rangle, | 11 \\rangle$ 為 $H_4$ 的基底</p><h4 id="範例-2" tabindex="-1">範例 <a class="header-anchor" href="#範例-2" aria-label="Permalink to &quot;範例&quot;">​</a></h4><p>假設：</p><ul><li>第 0 個 $H_2$：$| 0 \\rangle _0 = \\begin{pmatrix} 1 \\ 0 \\end{pmatrix}$, $| 1 \\rangle _0 = \\begin{pmatrix} 0 \\ 1 \\end{pmatrix}$, $T_0$ operator</li><li>第 1 個 $H_2$：$| 0 \\rangle _1 = \\begin{pmatrix} 1 \\ 0 \\end{pmatrix}$, $| 1 \\rangle _1 = \\begin{pmatrix} 0 \\ 1 \\end{pmatrix}$, $T_1$ operator</li></ul><p>計算張量積：</p><p>$$ | 0 \\rangle _{10} = |00 \\rangle _2 = | 0 \\rangle _1 \\otimes |0 \\rangle _0 = \\begin{pmatrix} 1 \\ 0 \\end{pmatrix} \\otimes \\begin{pmatrix} 1 \\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\ 0 \\ 0 \\ 0 \\end{pmatrix} $$</p><p>$$ | 1 \\rangle _{10} = |01 \\rangle _2 = | 0 \\rangle _1 \\otimes |1 \\rangle _0 = \\begin{pmatrix} 1 \\ 0 \\end{pmatrix} \\otimes \\begin{pmatrix} 0 \\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \\end{pmatrix} $$</p><p>$$ | 2 \\rangle _{10} = |10 \\rangle _2 = | 1 \\rangle _1 \\otimes |0 \\rangle _0 = \\begin{pmatrix} 0 \\ 1 \\end{pmatrix} \\otimes \\begin{pmatrix} 1 \\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\ 0 \\ 1 \\ 0 \\end{pmatrix} $$</p><p>$$ | 3 \\rangle _{10} = |11 \\rangle _2 = | 1 \\rangle _1 \\otimes |1 \\rangle _0 = \\begin{pmatrix} 0 \\ 1 \\end{pmatrix} \\otimes \\begin{pmatrix} 0 \\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\ 0 \\ 0 \\ 1 \\end{pmatrix} $$</p><h3 id="運算子與單元矩陣" tabindex="-1">運算子與單元矩陣 <a class="header-anchor" href="#運算子與單元矩陣" aria-label="Permalink to &quot;運算子與單元矩陣&quot;">​</a></h3><p>在多量子位系統中，運算子 $T$ 和單位運算子 $I$ 的結合可以用來描述量子態的演化。假設 $T_0$ 和 $T_1$ 是作用於不同量子位的運算子，若它們相等，即 $T_0 = T_1 = T$，則可以簡化為單一運算子 $T$ 的作用。</p><p>單位運算子 $I$ 的作用不會改變量子態，滿足以下關係：</p><p>$$ I |\\psi\\rangle = |\\psi\\rangle $$</p><p>其中，單位運算子 $I$ 的矩陣形式為：</p><p>$$ I = \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} $$</p><p>當運算子 $T$ 作用於單一量子位的量子態時，可以表示為：</p><p>$$ T | \\psi _1 \\rangle, | \\psi _0 \\rangle $$</p><p>而當運算子 $T$ 與單位運算子 $I$ 結合，作用於多量子位系統的張量積態時，則可以表示為：</p><p>$$ (T \\otimes I) (| \\psi _1 \\rangle \\otimes | \\psi _0 \\rangle) $$</p><p><strong>單位運算子</strong>：</p><p>$$ I \\otimes I = \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} \\otimes \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\times \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} &amp; 0 \\times \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} \\ 0 \\times \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} &amp; 1 \\times \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} = I $$</p><h4 id="單元矩陣-unitary-matrix" tabindex="-1">單元矩陣 (Unitary Matrix) <a class="header-anchor" href="#單元矩陣-unitary-matrix" aria-label="Permalink to &quot;單元矩陣 (Unitary Matrix)&quot;">​</a></h4><p>假設 $U$ ：</p><p>$$ U = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; i \\ i &amp; 1 \\end{pmatrix} $$</p><p>則可發現 $U^{-1} = U^\\dagger$</p><p><strong>Note</strong>：共軛轉置 (conjugate) $U^\\dagger = (U^*)^T$</p><p>$$ U^{-1} = [\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; i \\ i &amp; 1 \\end{pmatrix}]^* = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; -i \\ -i &amp; 1 \\end{pmatrix} $$</p><p>$$ U^\\dagger U = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; -i \\ -i &amp; 1 \\end{pmatrix} \\cdot \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; i \\ i &amp; 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 2 &amp; 0 \\ 0 &amp; 2 \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} = I $$</p><p>$$ U U^\\dagger = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; i \\ i &amp; 1 \\end{pmatrix} \\cdot \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; -i \\ -i &amp; 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 2 &amp; 0 \\ 0 &amp; 2 \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} = I $$</p><p>$U$ 是 Unitary Matrix</p><hr><h2 id="量子門與狀態轉換-quantum-gates-and-state-transformations" tabindex="-1">量子門與狀態轉換 (Quantum Gates and State Transformations) <a class="header-anchor" href="#量子門與狀態轉換-quantum-gates-and-state-transformations" aria-label="Permalink to &quot;量子門與狀態轉換 (Quantum Gates and State Transformations)&quot;">​</a></h2><h3 id="常見量子門" tabindex="-1">常見量子門 <a class="header-anchor" href="#常見量子門" aria-label="Permalink to &quot;常見量子門&quot;">​</a></h3><p>$H_2$ 的基本運算子為 $I, X, Y, Z$</p><h4 id="基本運算子-x-not" tabindex="-1">基本運算子 - X (NOT) <a class="header-anchor" href="#基本運算子-x-not" aria-label="Permalink to &quot;基本運算子 - X (NOT)&quot;">​</a></h4><p>$$ X | 0 \\rangle = | 1 \\rangle, \\quad X | 1 \\rangle = | 0 \\rangle $$</p><p>$$ X = \\begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\end{pmatrix} $$</p><p>其中：</p><p>$$ X^2 = I = X^{-1}X $$</p><p>$$ X^{-1} = X $$</p><h4 id="基本運算子-y" tabindex="-1">基本運算子 - Y <a class="header-anchor" href="#基本運算子-y" aria-label="Permalink to &quot;基本運算子 - Y&quot;">​</a></h4><p>$$ Y | 0 \\rangle = +i | 1 \\rangle, \\quad Y | 1 \\rangle = -i | 0 \\rangle $$</p><p>$$ Y = \\begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \\end{pmatrix} $$</p><p>其中：</p><p>$$ Y^\\dagger = Y $$</p><p>$$ Y^\\dagger Y = \\begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \\end{pmatrix} \\begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{pmatrix} = I $$</p><p>$$ Y^2 = I $$</p><p>$Y$ 是單元矩陣</p><h4 id="基本運算子-z" tabindex="-1">基本運算子 - Z <a class="header-anchor" href="#基本運算子-z" aria-label="Permalink to &quot;基本運算子 - Z&quot;">​</a></h4><p>$$ Z | 0 \\rangle = | 0 \\rangle, \\quad Z | 1 \\rangle = -| 1 \\rangle $$</p><p>$$ Z = \\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; -1 \\end{pmatrix} $$</p><h3 id="糾纏態與測量" tabindex="-1">糾纏態與測量 <a class="header-anchor" href="#糾纏態與測量" aria-label="Permalink to &quot;糾纏態與測量&quot;">​</a></h3><p>在$H_2$中，</p><p>$$ U = \\alpha I + \\beta X + \\gamma Y + \\delta Z $$</p><h4 id="bell-state-貝爾態" tabindex="-1">Bell State （貝爾態） <a class="header-anchor" href="#bell-state-貝爾態" aria-label="Permalink to &quot;Bell State （貝爾態）&quot;">​</a></h4><p>$$ \\frac{1}{\\sqrt{2}} (| 00 \\rangle + | 11 \\rangle) $$</p><p>$$ \\frac{1}{\\sqrt{2}} (| 00 \\rangle - | 11 \\rangle) $$</p><p>$$ \\frac{1}{\\sqrt{2}} (| 01 \\rangle + | 10 \\rangle) $$</p><p>$$ \\frac{1}{\\sqrt{2}} (| 01 \\rangle - | 10 \\rangle) $$</p><p>Bell State 是兩個 qubit 之間最純粹的糾纏態。</p><p>假設：</p><p>$$ | \\psi_1 \\rangle = \\alpha_1 | 0 \\rangle + \\beta_1 | 1 \\rangle, \\quad | \\psi_0 \\rangle = \\alpha_0 | 0 \\rangle + \\beta_0 | 1 \\rangle $$</p><p>則它們的張量積</p><p>$$ | \\psi_1 \\rangle \\otimes | \\psi_0 \\rangle = \\alpha_1 \\alpha_0 | 00 \\rangle + \\alpha_1 \\beta_0 | 01 \\rangle + \\beta_1 \\alpha_0 | 10 \\rangle + \\beta_1 \\beta_0 | 11 \\rangle $$</p><p>如果 $\\beta_1 \\alpha_0 = \\alpha_1 \\beta_0 = 0$，則為 <strong>可分離態</strong>；否則為 <strong>糾纏態 (entanglement)</strong>。</p><h4 id="糾纏測量" tabindex="-1">糾纏測量 <a class="header-anchor" href="#糾纏測量" aria-label="Permalink to &quot;糾纏測量&quot;">​</a></h4><p>$$ \\alpha_1 \\alpha_0 | 00 \\rangle + \\beta_1 \\beta_0 | 11 \\rangle \\neq | \\psi_1 \\rangle \\otimes | \\psi_0 \\rangle $$</p><p>例如：</p><p>$$ | 00 \\rangle + | 11 \\rangle = | 0 \\rangle _1 \\otimes | 0 \\rangle _0 + | 1 \\rangle _1 \\otimes | 1 \\rangle _0 $$</p><p><img src="'+$+'" alt="Entangled Measurement"></p><p>此時去做量子測量：</p><ul><li>第 1 個質點測量到 $| 0 \\rangle$，則第 0 個質點就確定為 $| 0 \\rangle$</li><li>第 1 個質點測量到 $| 1 \\rangle$，則第 0 個質點就確定為 $| 1 \\rangle$</li></ul><p><img src="'+o+'" alt="Quantum Measurement Multiple"></p><h3 id="逆向計算-reverse-computation" tabindex="-1">逆向計算 (Reverse Computation) <a class="header-anchor" href="#逆向計算-reverse-computation" aria-label="Permalink to &quot;逆向計算 (Reverse Computation)&quot;">​</a></h3><h4 id="cnot-control-not" tabindex="-1">CNOT (Control NOT) <a class="header-anchor" href="#cnot-control-not" aria-label="Permalink to &quot;CNOT (Control NOT)&quot;">​</a></h4><p>CNOT 門的運作如下：</p><p><img src="'+m+'" alt="CNOT Gate"></p><p>$$ \\text{CNOT} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{pmatrix} = \\begin{pmatrix} I &amp; O \\ O &amp; X \\end{pmatrix} $$</p><p><strong>CNOT 性質</strong>：</p><p>$$ \\text{CNOT} \\cdot \\text{CNOT} = I $$</p><p>$$ \\text{CNOT}^{-1} \\cdot \\text{CNOT} = I $$</p><p>$$ \\text{CNOT}^{-1} = \\text{CNOT} $$</p><p>舉個例子：</p><table tabindex="0"><thead><tr><th>$1 \\otimes 0 = 1$</th><th>$1 \\otimes 1 = 0$</th></tr></thead><tbody><tr><td><img src="'+g+'" alt="Example 1"></td><td><img src="'+h+'" alt="Example 2"></td></tr></tbody></table><p>這是所有計算中最重要的一個運算門，並且可以延伸出 COPY、NOT 和 SWAP 三種操作：</p><table tabindex="0"><thead><tr><th>COPY</th><th>NOT</th><th>SWAP</th></tr></thead><tbody><tr><td><img src="'+d+'" alt="COPY Gate"></td><td><img src="'+c+'" alt="NOT Gate"></td><td><img src="'+u+'" alt="SWAP Gate (Using CNOT)"></td></tr></tbody></table><h4 id="ccnot-toffoli-gate" tabindex="-1">CCNOT (Toffoli Gate) <a class="header-anchor" href="#ccnot-toffoli-gate" aria-label="Permalink to &quot;CCNOT (Toffoli Gate)&quot;">​</a></h4><p>CCNOT 門的運作如下：</p><p><img src="'+_+'" alt="CCNOT Gate"></p><ul><li>$a=0, b=0 \\implies ab=0 \\implies | c \\oplus ab \\rangle = | c \\oplus 0 \\rangle = | c \\rangle$</li><li>$a=1, b=1 \\implies ab=1 \\implies | c \\oplus ab \\rangle = | c \\oplus 1 \\rangle = | \\overline{c} \\rangle$</li></ul><p><strong>CCNOT 性質</strong>：</p><p><img src="'+b+'" alt="CCNOT Reversibility"></p><p>$$ \\text{CCNOT} \\cdot \\text{CCNOT} = I $$</p><p>$$ \\text{CCNOT}^{-1} \\cdot \\text{CCNOT} = I $$</p><p>$$ \\text{CCNOT}^{-1} = \\text{CCNOT} $$</p><h3 id="邏輯運算門" tabindex="-1">邏輯運算門 <a class="header-anchor" href="#邏輯運算門" aria-label="Permalink to &quot;邏輯運算門&quot;">​</a></h3><h4 id="and" tabindex="-1">AND <a class="header-anchor" href="#and" aria-label="Permalink to &quot;AND&quot;">​</a></h4><p>AND 的運作如下：</p><p><img src="'+x+'" alt="AND Gate"></p><h4 id="xor" tabindex="-1">XOR <a class="header-anchor" href="#xor" aria-label="Permalink to &quot;XOR&quot;">​</a></h4><p>XOR 的運作如下：</p><p><img src="'+q+'" alt="XOR Gate"></p><h4 id="nand-not-and" tabindex="-1">NAND (NOT AND) <a class="header-anchor" href="#nand-not-and" aria-label="Permalink to &quot;NAND (NOT AND)&quot;">​</a></h4><p>NAND 的運作如下：</p><p><img src="'+f+'" alt="NAND Gate"></p><h4 id="not" tabindex="-1">NOT <a class="header-anchor" href="#not" aria-label="Permalink to &quot;NOT&quot;">​</a></h4><p>NOT 也可以用 CNOT 的形式來表示：</p><p><img src="'+N+'" alt="NOT Gate"></p><h4 id="or" tabindex="-1">OR <a class="header-anchor" href="#or" aria-label="Permalink to &quot;OR&quot;">​</a></h4><p>OR 的運作如下：</p><p><img src="'+P+'" alt="OR Gate"></p><h5 id="範例-3" tabindex="-1">範例 <a class="header-anchor" href="#範例-3" aria-label="Permalink to &quot;範例&quot;">​</a></h5><p>以下是量子電路的等價性：</p><p><img src="'+T+'" alt="Quantum Circuit Equivalence"></p><hr><h2 id="量子傳輸" tabindex="-1">量子傳輸 <a class="header-anchor" href="#量子傳輸" aria-label="Permalink to &quot;量子傳輸&quot;">​</a></h2><h2 id="量子演算法" tabindex="-1">量子演算法 <a class="header-anchor" href="#量子演算法" aria-label="Permalink to &quot;量子演算法&quot;">​</a></h2><h3 id="bernstein-vazirani-algorithm" tabindex="-1">Bernstein-Vazirani Algorithm <a class="header-anchor" href="#bernstein-vazirani-algorithm" aria-label="Permalink to &quot;Bernstein-Vazirani Algorithm&quot;">​</a></h3><h3 id="simon-s-algorithm" tabindex="-1">Simon&#39;s Algorithm <a class="header-anchor" href="#simon-s-algorithm" aria-label="Permalink to &quot;Simon&#39;s Algorithm&quot;">​</a></h3><h3 id="shor-s-algorithm" tabindex="-1">Shor&#39;s Algorithm <a class="header-anchor" href="#shor-s-algorithm" aria-label="Permalink to &quot;Shor&#39;s Algorithm&quot;">​</a></h3><h3 id="grover-s-algorithm" tabindex="-1">Grover&#39;s Algorithm <a class="header-anchor" href="#grover-s-algorithm" aria-label="Permalink to &quot;Grover&#39;s Algorithm&quot;">​</a></h3><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><a href="https://howardpeng911.medium.com/shor-algorithm-2c1abca22da2" target="_blank" rel="noreferrer">Shor&#39;s Algorithm - 量子計算初學者的理解</a></li><li><a href="https://youtu.be/lvTqbM5Dq4Q" target="_blank" rel="noreferrer">How Quantum Computers Break Encryption | Shor&#39;s Algorithm Explained</a></li></ul>',237)])])}const H=e(k,[["render",y]]);export{B as __pageData,H as default};
